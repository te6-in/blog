---
import { Image } from "astro:assets";
import { getCollection } from "astro:content";
import { $path } from "astro-typesafe-routes/path";
import { AlertTriangle } from "lucide-astro";
import type { Blog, BlogPosting, WithContext } from "schema-dts";
import JsonLd from "../components/JsonLd.astro";
import { Navigations } from "../components/Navigations";
import PostGrid from "../components/PostGrid";
import PostGridItem from "../components/PostGrid/PostGridItem.astro";
import PostWithCommentsSkeleton from "../components/PostWithComments/PostWithCommentsSkeleton.astro";
import PostWithCommentsTemplate from "../components/PostWithComments/PostWithCommentsTemplate.astro";
import Layout from "../layouts/Layout.astro";
import { getBlogAuthorPerson, getPostBlogPostingId, getSnippetBlogPostingId } from "../lib/json-ld";
import { METADATA } from "../lib/metadata";

const posts = await getCollection("post");
const snippets = await getCollection("snippet");

const featuredPosts = posts
  .filter(({ data: { featured } }) => featured)
  .sort(({ data: { publishedAt: a } }, { data: { publishedAt: b } }) => b.getTime() - a.getTime())
  .slice(0, 6);

const person = getBlogAuthorPerson(Astro.url);

const blog: WithContext<Blog> = {
  "@context": "https://schema.org",
  "@type": "Blog",
  name: METADATA.name,
  alternateName: METADATA.previousName,
  description: METADATA.description,
  keywords: METADATA.keywords,
  author: {
    "@type": "Person",
    "@id": person["@id"],
  },
  copyrightHolder: {
    "@type": "Person",
    "@id": person["@id"],
  },
  url: Astro.url.origin,
  dateCreated: METADATA.createdAt.toISOString(),
  datePublished: METADATA.createdAt.toISOString(),
  dateModified: METADATA.updatedAt.toISOString(),
  discussionUrl: METADATA.discussions.url,
  thumbnailUrl: new URL("/images/default-og-image.png", Astro.url.origin).href,
  blogPost: [
    ...posts.map(
      (post) =>
        ({
          "@context": "https://schema.org",
          "@type": "BlogPosting",
          "@id": getPostBlogPostingId(post, Astro.url),
        }) satisfies WithContext<BlogPosting>,
    ),
    ...snippets.map(
      (snippet) =>
        ({
          "@context": "https://schema.org",
          "@type": "BlogPosting",
          "@id": getSnippetBlogPostingId(snippet, Astro.url),
        }) satisfies WithContext<BlogPosting>,
    ),
  ],
};
---

<Layout
  metadataProps={{
    canonicalUrl: new URL($path({ to: "/" }), Astro.url.origin).href,
  }}
>
  <div class="flex flex-col">
    <div class="flex flex-col gap-6 mb-12">
      <div
        class="rounded-2xl overflow-hidden ml-8 mt-8 after:rounded-2xl media-border self-start shadow-xl shadow-sky-700/15 dark:shadow-sky-300/15"
      >
        <Image
          loading="eager"
          fetchpriority="high"
          src={METADATA.author.avatar}
          alt=""
          width={120}
          height={120}
          onload="this.classList.remove('not-noscript:motion-safe:animate-pulse')"
          class="bg-gray-200 dark:bg-zinc-800 not-noscript:motion-safe:animate-pulse"
          aria-hidden
        />
      </div>
      <h1 class="font-semibold text-3xl leading-11 mx-8 text-gray-800 dark:text-zinc-200">
        <span class="whitespace-nowrap">안녕하세요.</span>
        <span class="whitespace-nowrap">{METADATA.name}입니다.</span>
      </h1>
    </div>
    <div class="flex flex-col gap-1">
      <h2 class="font-medium text-lg text-balance ml-8 text-gray-600 dark:text-zinc-400">
        추천드리는 글
      </h2>
      <PostGrid
        class="p-4 sidebar-shown:p-3 grid-cols-2 sidebar-shown:grid-cols-1 md:grid-cols-2 toc-shown:grid-cols-3 gap-x-px gap-y-2 sidebar-shown:gap-1 transition-[gap,padding]"
      >
        {featuredPosts.map(
            ({ data: { title, description, coverImage }, id }) => (
              <li>
                <PostGridItem
                  class="featured-anchor"
                  slug={id}
                  title={title}
                  description={description}
                  coverImage={coverImage}
                />
              </li>
            )
          )}
      </PostGrid>
    </div>
    <section id="recent-commented-posts-section" class="flex flex-col gap-1">
      <h2 class="font-medium text-lg text-balance ml-8 text-gray-600 dark:text-zinc-400">
        최근 댓글이 달린 글
      </h2>
      <ol
        class="relative min-h-[320px] m-0 p-4 sidebar-shown:p-3 grid grid-cols-2 sidebar-shown:grid-cols-1 md:grid-cols-2 toc-shown:grid-cols-3 gap-x-px gap-y-2 sidebar-shown:gap-1 transition-[gap,padding]"
        id="recent-commented-posts"
      >
        {Array.from({ length: 6 }).map(() => (
          <PostWithCommentsSkeleton class="recent-commented-loader-item" />
        ))}
        <PostWithCommentsTemplate id="post-grid-item" />
        <li
          id="recent-commented-posts-error"
          hidden
          class="absolute inset-0 z-20 grid place-items-center p-4"
        >
          <div class="flex flex-col items-center gap-1 text-center">
            <span class="rounded-full p-1.5 bg-content-card-bg dark:bg-content-card-bg-dark">
              <AlertTriangle size={27} class="text-gray-500 dark:text-zinc-400" />
            </span>
            <p
              id="recent-commented-posts-error-message"
              class="rounded-md px-2 py-1 text-base leading-snug text-gray-600 dark:text-zinc-400 bg-content-card-bg dark:bg-content-card-bg-dark"
            >
              최근 댓글을 불러오지 못했어요.
            </p>
            <button
              id="recent-commented-posts-retry"
              type="button"
              class="mt-3 px-3.5 py-2 rounded-full bg-content-card-bg dark:bg-content-card-bg-dark border border-gray-200 dark:border-zinc-800 text-sm font-semibold text-gray-800 dark:text-zinc-200 engaged:bg-gray-100 dark:engaged:bg-zinc-900 transition-colors cursor-pointer"
            >
              다시 시도
            </button>
          </div>
        </li>
      </ol>
    </section>
    <div class="flex gap-2 self-center mt-6 mb-12 px-4 flex-wrap justify-center">
      <Navigations.Posts />
      <Navigations.Snippets />
    </div>
  </div>
</Layout>

<JsonLd data={[blog, person]} />

<script>
import { prefetch } from "astro:prefetch";
import { Octokit } from "@octokit/core";
import { $path } from "astro-typesafe-routes/path";
import type { DiscussionCommentsResponse, DiscussionsResponse } from "../lib/github";
import { METADATA } from "../lib/metadata";
import type { PostsResponse } from "./api/posts";

const octokit = new Octokit();
let isLoading = false;

const retryButton = document.getElementById("recent-commented-posts-retry");
if (retryButton instanceof HTMLButtonElement) {
  retryButton.addEventListener("click", () => {
    void main();
  });
}

await main();

async function fetchPosts() {
  const response = await fetch($path({ to: "/api/posts" }));
  if (!response.ok) throw new Error("Failed to fetch posts.");

  return (await response.json()) as PostsResponse;
}

async function fetchDiscussions() {
  const response = await octokit.request("GET /repos/{owner}/{repo}/discussions", {
    owner: METADATA.discussions.repo.owner,
    repo: METADATA.discussions.repo.name,
    per_page: 100,
  });

  return response.data as DiscussionsResponse;
}

async function fetchDiscussionComments(discussionNumber: number) {
  const response = await octokit.request(
    "GET /repos/{owner}/{repo}/discussions/{discussion_number}/comments",
    {
      owner: METADATA.discussions.repo.owner,
      repo: METADATA.discussions.repo.name,
      discussion_number: discussionNumber,
      per_page: 100,
    },
  );

  return response.data as DiscussionCommentsResponse;
}

function toCommentPreview(commentBody: string, maxLength = 180) {
  const normalized = commentBody.replace(/\s+/g, " ").trim();
  if (!normalized) return "";
  if (normalized.length <= maxLength) return normalized;

  return `${normalized.slice(0, maxLength - 1)}…`;
}

function appendCommentPreview(
  commentsContainer: HTMLElement,
  comment: DiscussionCommentsResponse[number],
) {
  const commentWrapper = document.createElement("div");
  commentWrapper.className = "flex items-start gap-1.5 text-sm leading-normal";

  const avatarWrapper = document.createElement("span");
  avatarWrapper.className =
    "size-[1lh] rounded-full overflow-hidden media-border after:rounded-full bg-gray-200 dark:bg-zinc-700 flex-none shrink-0";

  const avatar = document.createElement("img");
  avatar.className = "size-full object-cover";
  avatar.src = comment.user.avatar_url;
  avatar.alt = "";
  avatar.width = 19;
  avatar.height = 19;
  avatar.loading = "lazy";
  avatar.decoding = "async";
  avatar.referrerPolicy = "no-referrer";

  const commentBody = document.createElement("p");
  commentBody.className = "text-gray-600 dark:text-zinc-400 line-clamp-3 break-words";
  commentBody.textContent = toCommentPreview(comment.body);

  avatarWrapper.append(avatar);
  commentWrapper.append(avatarWrapper, commentBody);
  commentsContainer.append(commentWrapper);
}

function appendHiddenCommentsCount(commentsContainer: HTMLElement, hiddenCommentsCount: number) {
  if (hiddenCommentsCount <= 0) return;

  const hiddenCommentsLabel = document.createElement("p");
  hiddenCommentsLabel.className =
    "ml-[calc(1lh+var(--spacing)*1.5)] text-[0.6875rem] font-medium leading-normal text-gray-500 dark:text-zinc-500";
  hiddenCommentsLabel.textContent = `+${hiddenCommentsCount}`;
  commentsContainer.append(hiddenCommentsLabel);
}

function getGridItemClone(
  template: HTMLTemplateElement,
  item: {
    coverImage: { src: string; alt: string };
    title: string;
    href: string;
    comments: DiscussionCommentsResponse;
    hiddenCommentsCount: number;
  },
) {
  const clone = template.content.cloneNode(true) as DocumentFragment;

  const listItem = clone.querySelector("li");
  const anchor = clone.querySelector("a");
  const image = clone.querySelector(".cover-image");
  const title = clone.querySelector(".title");
  const comments = clone.querySelector(".comments");

  if (!(listItem instanceof HTMLLIElement)) throw new Error("Missing list item in template.");
  if (!(anchor instanceof HTMLAnchorElement)) throw new Error("Missing anchor in template.");
  if (!(image instanceof HTMLImageElement)) throw new Error("Missing image in template.");
  if (!(title instanceof HTMLElement)) throw new Error("Missing title in template.");
  if (!(comments instanceof HTMLElement))
    throw new Error("Missing comments container in template.");

  anchor.addEventListener("mouseenter", () => prefetch(anchor.href));

  anchor.href = item.href;
  listItem.classList.add("recent-commented-post-card");
  image.src = item.coverImage.src;
  image.alt = item.coverImage.alt;
  title.textContent = item.title;
  for (const comment of item.comments) {
    appendCommentPreview(comments, comment);
  }
  appendHiddenCommentsCount(comments, item.hiddenCommentsCount);

  return clone;
}

function hideSection(section: HTMLElement | null) {
  section?.setAttribute("hidden", "true");
}

function clearRenderedCards(grid: HTMLElement) {
  for (const card of grid.querySelectorAll(".recent-commented-post-card")) {
    card.remove();
  }
}

function setLoadingState(
  grid: HTMLElement,
  loaderItems: HTMLElement[],
  errorLayer: HTMLElement | null,
  retryButtonElement: HTMLButtonElement | null,
) {
  for (const loaderItem of loaderItems) {
    loaderItem.classList.remove("hidden");
  }
  errorLayer?.setAttribute("hidden", "true");
  grid.setAttribute("aria-busy", "true");
  if (retryButtonElement) retryButtonElement.disabled = true;
}

function setErrorState(
  grid: HTMLElement,
  loaderItems: HTMLElement[],
  errorLayer: HTMLElement | null,
  errorMessage: HTMLElement | null,
  retryButtonElement: HTMLButtonElement | null,
  reason: string,
) {
  for (const loaderItem of loaderItems) {
    loaderItem.classList.add("hidden");
  }
  if (errorMessage) errorMessage.textContent = `최근 댓글을 불러오지 못했어요. ${reason}`;
  errorLayer?.removeAttribute("hidden");
  grid.removeAttribute("aria-busy");
  if (retryButtonElement) retryButtonElement.disabled = false;
}

function getErrorReason(error: unknown) {
  if (typeof error === "object" && error !== null) {
    const maybeError = error as { status?: number };

    if (maybeError.status === 403) {
      return "GitHub API 요청 한도에 도달했어요.";
    }
  }

  return "잠시 후 다시 시도해 주세요.";
}

async function main() {
  if (isLoading) return;
  isLoading = true;

  const section = document.getElementById("recent-commented-posts-section");
  const grid = document.getElementById("recent-commented-posts");
  const postGridItem = document.getElementById("post-grid-item");
  const errorLayer = document.getElementById("recent-commented-posts-error");
  const errorMessage = document.getElementById("recent-commented-posts-error-message");
  const retryButtonElement = document.getElementById("recent-commented-posts-retry");
  const retryButton = retryButtonElement instanceof HTMLButtonElement ? retryButtonElement : null;

  if (!(grid instanceof HTMLElement) || !(postGridItem instanceof HTMLTemplateElement)) {
    hideSection(section);
    isLoading = false;
    return;
  }

  const loaderItems = Array.from(
    grid.querySelectorAll<HTMLElement>(".recent-commented-loader-item"),
  );

  setLoadingState(grid, loaderItems, errorLayer, retryButton);
  clearRenderedCards(grid);

  try {
    const featuredPathnames = new Set(
      [...document.querySelectorAll<HTMLAnchorElement>(".featured-anchor")].map(
        (anchor) => new URL(anchor.href).pathname,
      ),
    );
    const [posts, discussions] = await Promise.all([fetchPosts(), fetchDiscussions()]);
    const postsById = new Map(posts.map((post) => [post.id, post]));
    const selectedPosts = new Set<string>();

    const sortedDiscussions = discussions
      .filter(({ title }) => title.startsWith("post/"))
      .filter(({ title }) => !featuredPathnames.has(`/${title}`))
      .sort((a, b) => new Date(b.updated_at).getTime() - new Date(a.updated_at).getTime());

    const postCards: {
      post: PostsResponse[number];
      comments: DiscussionCommentsResponse;
      hiddenCommentsCount: number;
    }[] = [];

    for (const discussion of sortedDiscussions) {
      if (postCards.length >= 6) break;

      const [, slug] = discussion.title.split("/", 2);
      if (!slug || selectedPosts.has(slug)) continue;

      const post = postsById.get(slug);
      if (!post || !post.data.coverImage) continue;

      const allComments = [...(await fetchDiscussionComments(discussion.number))].sort(
        (a, b) => new Date(b.created_at).getTime() - new Date(a.created_at).getTime(),
      );
      const displayableComments = allComments.filter(({ body }) => toCommentPreview(body) !== "");
      const latestComments = displayableComments.slice(0, 1);

      if (latestComments.length === 0) continue;

      selectedPosts.add(slug);
      postCards.push({
        post,
        comments: latestComments,
        hiddenCommentsCount: Math.max(allComments.length - latestComments.length, 0),
      });
    }

    if (postCards.length === 0) {
      hideSection(section);
      return;
    }

    const clones = postCards.map(({ post, comments, hiddenCommentsCount }) => {
      if (!post.data.coverImage) throw new Error("Missing cover image.");

      return getGridItemClone(postGridItem, {
        coverImage: post.data.coverImage,
        title: post.data.title,
        href: $path({ to: "/post/[slug]", params: { slug: post.id } }),
        comments,
        hiddenCommentsCount,
      });
    });

    grid.append(...clones);
    for (const loaderItem of loaderItems) {
      loaderItem.remove();
    }
    errorLayer?.setAttribute("hidden", "true");
  } catch (error) {
    setErrorState(grid, loaderItems, errorLayer, errorMessage, retryButton, getErrorReason(error));
  } finally {
    grid.removeAttribute("aria-busy");
    if (retryButton) retryButton.disabled = false;
    isLoading = false;
  }
}
</script>
