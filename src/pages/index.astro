---
import Layout from "../layouts/Layout.astro";
import type { WithContext, Blog, BlogPosting } from "schema-dts";
import { getCollection } from "astro:content";
import JsonLd from "../components/JsonLd.astro";
import {
  getBlogAuthorPerson,
  getPostBlogPostingId,
  getSnippetBlogPostingId,
} from "../lib/json-ld";
import { METADATA } from "../lib/metadata";
import { $path } from "astro-typesafe-routes/path";
import PostGrid from "../components/PostGrid";
// import PostWithCommentsSkeleton from "../components/PostWithComments/PostWithCommentsSkeleton.astro";
// import PostWithCommentsTemplate from "../components/PostWithComments/PostWithCommentsTemplate.astro";
import PostGridItem from "../components/PostGrid/PostGridItem.astro";
import { Image } from "astro:assets";
import { Navigations } from "../components/Navigations";

const posts = await getCollection("post");
const snippets = await getCollection("snippet");

const featuredPosts = posts
  .filter(({ data: { featured } }) => featured)
  .sort(
    ({ data: { publishedAt: a } }, { data: { publishedAt: b } }) =>
      b.getTime() - a.getTime()
  )
  .slice(0, 6);

const person = getBlogAuthorPerson(Astro.url);

const blog: WithContext<Blog> = {
  "@context": "https://schema.org",
  "@type": "Blog",
  name: METADATA.name,
  alternateName: METADATA.previousName,
  description: METADATA.description,
  keywords: METADATA.keywords,
  author: {
    "@type": "Person",
    "@id": person["@id"],
  },
  copyrightHolder: {
    "@type": "Person",
    "@id": person["@id"],
  },
  url: Astro.url.origin,
  dateCreated: METADATA.createdAt.toISOString(),
  datePublished: METADATA.createdAt.toISOString(),
  dateModified: METADATA.updatedAt.toISOString(),
  discussionUrl: METADATA.discussions.url,
  thumbnailUrl: new URL("/images/default-og-image.png", Astro.url.origin).href,
  blogPost: [
    ...posts.map(
      (post) =>
        ({
          "@context": "https://schema.org",
          "@type": "BlogPosting",
          "@id": getPostBlogPostingId(post, Astro.url),
        }) satisfies WithContext<BlogPosting>
    ),
    ...snippets.map(
      (snippet) =>
        ({
          "@context": "https://schema.org",
          "@type": "BlogPosting",
          "@id": getSnippetBlogPostingId(snippet, Astro.url),
        }) satisfies WithContext<BlogPosting>
    ),
  ],
};
---

<Layout
  metadataProps={{
    canonicalUrl: new URL($path({ to: "/" }), Astro.url.origin).href,
  }}
>
  <div class="flex flex-col">
    <div class="flex flex-col gap-6 mb-12">
      <div
        class="rounded-2xl overflow-hidden ml-8 mt-8 after:rounded-2xl media-border self-start shadow-xl shadow-sky-700/15 dark:shadow-sky-300/15"
      >
        <Image
          src={METADATA.author.avatar}
          alt=""
          width={120}
          height={120}
          onload="this.classList.remove('not-noscript:motion-safe:animate-pulse')"
          class="bg-gray-200 dark:bg-zinc-800 not-noscript:motion-safe:animate-pulse"
          aria-hidden
        />
      </div>
      <h1
        class="font-semibold text-3xl leading-11 mx-8 text-gray-800 dark:text-zinc-200"
      >
        <span class="whitespace-nowrap">안녕하세요.</span>
        <span class="whitespace-nowrap">{METADATA.name}입니다.</span>
      </h1>
    </div>
    <div class="flex flex-col gap-1">
      <h2
        class="font-medium text-lg text-balance ml-8 text-gray-600 dark:text-zinc-400"
      >
        추천드리는 글
      </h2>
      <PostGrid
        class="p-4 sidebar-shown:p-3 grid-cols-2 sidebar-shown:grid-cols-1 md:grid-cols-2 toc-shown:grid-cols-3 gap-x-px gap-y-2 sidebar-shown:gap-1 transition-[gap,padding]"
      >
        {
          featuredPosts.map(
            ({ data: { title, description, coverImage }, id }) => (
              <PostGridItem
                class="featured-anchor"
                slug={id}
                title={title}
                description={description}
                coverImage={coverImage}
              />
            )
          )
        }
      </PostGrid>
    </div>
    <!-- <div>최근 반응이 많은 글</div>
    <div class="p-2 flex flex-col gap-2" id="recently-engaged-posts">
      <div id="loader" class="contents">
        {Array.from({ length: 3 }).map(() => <PostWithCommentsSkeleton />)}
      </div>
      <PostWithCommentsTemplate id="post-grid-item" />
    </div> -->
    <div
      class="flex gap-2 self-center mt-6 mb-12 px-4 flex-wrap justify-center"
    >
      <Navigations.Posts />
      <Navigations.Snippets />
    </div>
  </div>
</Layout>

<JsonLd data={[blog, person]} />

<!-- <script>
  import { Octokit } from "@octokit/core";
  import { $path } from "astro-typesafe-routes/path";
  import type { PostsResponse } from "./api/posts";
  import type {
    DiscussionsResponse,
    DiscussionCommentsResponse,
  } from "../lib/github";
  import type { DataCollectionKey } from "astro:content";
  import { METADATA } from "../lib/metadata";
  import { prefetch } from "astro:prefetch";

  const octokit = new Octokit();

  await main();

  async function fetchPosts() {
    return (await fetch($path({ to: "/api/posts" })).then((res) =>
      res.json()
    )) as PostsResponse;
  }

  async function fetchDiscussions() {
    const response = await octokit.request(
      "GET /repos/{owner}/{repo}/discussions",
      {
        owner: METADATA.discussions.repo.owner,
        repo: METADATA.discussions.repo.name,
        per_page: 100,
      }
    );

    return response.data as DiscussionsResponse;
  }

  async function fetchDiscussionComments(discussionNumber: number) {
    const response = await octokit.request(
      "GET /repos/{owner}/{repo}/discussions/{discussion_number}/comments",
      {
        owner: METADATA.discussions.repo.owner,
        repo: METADATA.discussions.repo.name,
        discussion_number: discussionNumber,
        per_page: 100,
      }
    );

    return response.data as DiscussionCommentsResponse;
  }

  function getGridItemClone(
    template: HTMLTemplateElement,
    item: {
      coverImage: { src: string; alt: string };
      title: string;
      description: string;
      href: string;
    }
  ) {
    const clone = template.content.cloneNode(true) as DocumentFragment;

    const anchor = clone.querySelector("a") as HTMLAnchorElement;
    const image = clone.querySelector(".cover-image") as HTMLImageElement;
    const title = clone.querySelector(".title") as HTMLElement;
    const description = clone.querySelector(".description") as HTMLElement;

    anchor.addEventListener("mouseenter", () => prefetch(anchor.href));

    anchor.href = item.href;
    image.src = item.coverImage.src;
    image.alt = item.coverImage.alt;
    title.textContent = item.title;
    description.textContent = item.description;

    return clone;
  }

  async function main() {
    const loader = document.getElementById("loader");

    const featuredAnchorsHrefs = [
      ...document.querySelectorAll<HTMLAnchorElement>(".featured-anchor"),
    ].map((anchor) => anchor.href);

    const recentlyCommentedPostsGrid = document.getElementById(
      "recently-engaged-posts"
    );

    const postGridItem = document.getElementById(
      "post-grid-item"
    ) as HTMLTemplateElement;

    if (!recentlyCommentedPostsGrid || !postGridItem) {
      console.warn("recentlyCommentedPostsGrid or postGridItem not found");

      return;
    }

    const [posts, discussions] = await Promise.all([
      fetchPosts(),
      fetchDiscussions(),
    ]);

    const recentlyEngaged = discussions
      .filter(({ title }) => {
        if (title.split("/")[0] !== ("post" satisfies DataCollectionKey)) {
          return false;
        }

        // prevent featured posts from being shown
        if (
          featuredAnchorsHrefs.some(
            (href) => new URL(href).pathname === `/${title}`
          )
        ) {
          return false;
        }

        return true;
      })
      .sort(
        (a, b) =>
          new Date(b.updated_at).getTime() - new Date(a.updated_at).getTime()
      )
      .map((discussion) => ({
        discussion,
        post: posts.find(({ id }) => id === discussion.title.split("/")[1]),
      }))
      .filter(
        ({ post }) => post && post.data.coverImage // coverImage가 있는 post만 사용
      )
      .slice(0, 3);

    const clones = recentlyEngaged.map(({ post }) => {
      // not happening, just for type safety
      if (!post) throw new Error("post is undefined");
      if (!post.data.coverImage)
        throw new Error("post.data.coverImage is undefined");

      return getGridItemClone(postGridItem, {
        coverImage: post.data.coverImage,
        title: post.data.title,
        description: post.data.description,
        href: $path({ to: "/post/[slug]", params: { slug: post.id } }),
      });
    });

    recentlyCommentedPostsGrid.append(...clones);
    loader?.remove();

    const recentComments = await Promise.all(
      recentlyEngaged.map(async ({ discussion, post }) => {
        // not happening, just for type safety
        if (!post) throw new Error("post is undefined");

        return {
          post,
          discussion,
          comments: await fetchDiscussionComments(discussion.number),
        };
      })
    );

    const recentlyEngagedAnchors =
      recentlyCommentedPostsGrid.querySelectorAll<HTMLAnchorElement>("a");

    for (const anchor of recentlyEngagedAnchors) {
      const { comments } =
        recentComments.find(
          ({ discussion }) =>
            new URL(anchor.href).pathname === `/${discussion.title}`
        ) || {};

      if (!comments) continue;

      console.log(
        comments.sort(
          (a, b) =>
            new Date(b.created_at).getTime() - new Date(a.created_at).getTime()
        )
      );
    }
  }
</script> -->
